from datetime import datetime
from sqlalchemy import func, text, and_, or_, desc, foreign
# Use core.db to avoid circular dependency
from core import db

class ActivityLog(db.Model):
    """Model for tracking activity in the application."""
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    action = db.Column(db.String(100), nullable=False)
    details = db.Column(db.Text)
    created_at = db.Column(db.DateTime, default=datetime.now)
    
    def __repr__(self):
        return f"<ActivityLog {self.action}>"

class JobRun(db.Model):
    """Model for tracking scraper job runs."""
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    start_time = db.Column(db.DateTime, default=datetime.now)
    end_time = db.Column(db.DateTime)
    status = db.Column(db.String(20))  # 'running', 'completed', 'failed'
    error = db.Column(db.Text)
    items_processed = db.Column(db.Integer, default=0)
    created_at = db.Column(db.DateTime, default=datetime.now)
    
    def __repr__(self):
        return f"<JobRun {self.id} - {self.status}>"

class NarrprCredential(db.Model):
    """Model for storing NARRPR credentials."""
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(255), nullable=False)
    password = db.Column(db.String(255), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.now)
    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)
    
    def __repr__(self):
        return f"<NarrprCredential {self.username}>"

class AIFeedback(db.Model):
    """Model for storing feedback on AI agent responses."""
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    agent_type = db.Column(db.String(50), nullable=False)  # summarizer, market_analyzer, recommender, nl_search
    query_data = db.Column(db.Text, nullable=False)  # The input provided to the agent
    response_data = db.Column(db.Text, nullable=False)  # The response generated by the agent
    rating = db.Column(db.Integer, nullable=False)  # 1-5 star rating
    comments = db.Column(db.Text, nullable=True)  # Optional user comments
    session_id = db.Column(db.String(64), nullable=True)  # To group multiple interactions from same session
    prompt_version_id = db.Column(db.Integer, nullable=True)  # The prompt version used
    extra_data = db.Column(db.Text, nullable=True)  # JSON blob with additional metadata (e.g., A/B test data)
    created_at = db.Column(db.DateTime, default=datetime.now)
    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)
    
    # Remove relationship to avoid circular dependency
    # prompt_version = db.relationship('PromptVersion', backref=db.backref('feedback', lazy=True))
    
    def __repr__(self):
        return f"<AIFeedback {self.agent_type} - {self.rating} stars>"
        
class AIFeedbackReportSettings(db.Model):
    """Model for storing AI feedback report settings."""
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    
    # Recipients
    admin_email = db.Column(db.String(255), nullable=True)  # Primary admin email for reports
    additional_recipients = db.Column(db.Text, nullable=True)  # JSON array of additional email addresses
    
    # Schedule settings
    send_daily_reports = db.Column(db.Boolean, default=False)
    send_weekly_reports = db.Column(db.Boolean, default=True)
    send_monthly_reports = db.Column(db.Boolean, default=True)
    
    # Weekly report day (0-6, Monday to Sunday)
    weekly_report_day = db.Column(db.Integer, default=0)
    
    # Monthly report day (1-31)
    monthly_report_day = db.Column(db.Integer, default=1)
    
    # Report content settings
    include_detailed_feedback = db.Column(db.Boolean, default=True)
    include_csv_attachment = db.Column(db.Boolean, default=True)
    include_excel_attachment = db.Column(db.Boolean, default=True)
    
    # Updated timestamp
    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)
    
    def __repr__(self):
        return f"<AIFeedbackReportSettings id={self.id}>"
    
    @staticmethod
    def get_settings():
        """Get the current settings, creating default settings if none exist."""
        from app import db
        
        settings = AIFeedbackReportSettings.query.first()
        if not settings:
            settings = AIFeedbackReportSettings()
            db.session.add(settings)
            db.session.commit()
        
        return settings
        
class PromptABTest(db.Model):
    """Model for storing A/B test data for prompt optimization."""
    id = db.Column(db.Integer, primary_key=True)
    agent_type = db.Column(db.String(50), nullable=False)  # Type of agent being tested
    original_prompt = db.Column(db.Text, nullable=False)  # Version A (original)
    improved_prompt = db.Column(db.Text, nullable=False)  # Version B (improved)
    start_date = db.Column(db.DateTime, nullable=False, default=datetime.now)
    end_date = db.Column(db.DateTime, nullable=False)
    status = db.Column(db.String(20), nullable=False)  # 'active', 'completed', 'cancelled'
    results = db.Column(db.Text, nullable=True)  # JSON blob with test results
    created_at = db.Column(db.DateTime, default=datetime.now)
    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)
    
    def __repr__(self):
        return f"<PromptABTest id={self.id} agent={self.agent_type} status={self.status}>"
        
class PromptVersion(db.Model):
    """Model for storing prompt versions for different agents."""
    id = db.Column(db.Integer, primary_key=True)
    agent_type = db.Column(db.String(50), nullable=False)  # Type of agent
    version = db.Column(db.Integer, nullable=False)  # Version number
    prompt_text = db.Column(db.Text, nullable=False)  # The prompt text
    is_active = db.Column(db.Boolean, default=False)  # Whether this is the currently active version
    notes = db.Column(db.Text, nullable=True)  # Notes about this version
    created_at = db.Column(db.DateTime, default=datetime.now)
    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)
    
    def __repr__(self):
        return f"<PromptVersion id={self.id} agent={self.agent_type} v{self.version} active={self.is_active}>"
    
    @staticmethod
    def get_active_prompt(agent_type):
        """Get the active prompt for a specific agent type."""
        from app import db
        
        prompt = PromptVersion.query.filter_by(
            agent_type=agent_type,
            is_active=True
        ).order_by(PromptVersion.version.desc()).first()
        
        if not prompt:
            # If no active prompt exists, get the latest version
            prompt = PromptVersion.query.filter_by(
                agent_type=agent_type
            ).order_by(PromptVersion.version.desc()).first()
            
            if prompt:
                # Make it active
                prompt.is_active = True
                db.session.commit()
        
        return prompt
        
class LearningCycle(db.Model):
    """Model for tracking AI continuous learning cycles."""
    id = db.Column(db.Integer, primary_key=True)
    start_date = db.Column(db.DateTime, nullable=False, default=datetime.now)
    end_date = db.Column(db.DateTime, nullable=True)
    status = db.Column(db.String(20), nullable=False, default='in_progress')  # 'in_progress', 'completed', 'failed', 'cancelled'
    agents_processed = db.Column(db.Integer, default=0)  # Number of agents processed
    agents_optimized = db.Column(db.Integer, default=0)  # Number of agents that were successfully optimized
    average_improvement = db.Column(db.Float, default=0.0)  # Average percentage improvement across all agents
    error_message = db.Column(db.Text, nullable=True)  # Error message if failed
    results = db.Column(db.Text, nullable=True)  # JSON blob with detailed results
    created_at = db.Column(db.DateTime, default=datetime.now)
    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)
    
    def __repr__(self):
        return f"<LearningCycle id={self.id} status={self.status} agents_optimized={self.agents_optimized}>"
        
class AgentOptimizationResult(db.Model):
    """Model for storing results of agent optimizations in learning cycles."""
    id = db.Column(db.Integer, primary_key=True)
    learning_cycle_id = db.Column(db.Integer, db.ForeignKey('learning_cycle.id'), nullable=False)
    agent_type = db.Column(db.String(50), nullable=False)  # Type of agent
    original_prompt_id = db.Column(db.Integer, db.ForeignKey('prompt_version.id'), nullable=True)
    new_prompt_id = db.Column(db.Integer, db.ForeignKey('prompt_version.id'), nullable=True)
    original_rating = db.Column(db.Float, nullable=True)  # Average rating before optimization
    new_rating = db.Column(db.Float, nullable=True)  # Average rating after optimization
    improvement_percentage = db.Column(db.Float, nullable=True)  # Percentage improvement
    tests_run = db.Column(db.Integer, default=0)  # Number of A/B tests run
    successful = db.Column(db.Boolean, default=False)  # Whether optimization was successful
    applied = db.Column(db.Boolean, default=False)  # Whether the optimization was applied
    notes = db.Column(db.Text, nullable=True)  # Notes about the optimization
    created_at = db.Column(db.DateTime, default=datetime.now)
    
    # Relationships
    learning_cycle = db.relationship('LearningCycle', backref=db.backref('agent_results', lazy=True))
    original_prompt = db.relationship('PromptVersion', foreign_keys=[original_prompt_id])
    new_prompt = db.relationship('PromptVersion', foreign_keys=[new_prompt_id])
    
    def __repr__(self):
        return f"<AgentOptimizationResult id={self.id} agent={self.agent_type} improvement={self.improvement_percentage}%>"
        
class AIIntegration(db.Model):
    """Model for storing AI integration configurations with external systems."""
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)  # Descriptive name for the integration
    integration_type = db.Column(db.String(50), nullable=False)  # Type of integration (e.g., webhook, api, email)
    agent_type = db.Column(db.String(50), nullable=False)  # Agent type this integration applies to
    config = db.Column(db.Text, nullable=False)  # JSON configuration for the integration
    is_active = db.Column(db.Boolean, default=True)  # Whether this integration is currently active
    last_executed = db.Column(db.DateTime, nullable=True)  # When this integration was last executed
    execution_count = db.Column(db.Integer, default=0)  # Number of times this integration has been executed
    created_at = db.Column(db.DateTime, default=datetime.now)
    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)
    
    def __repr__(self):
        return f"<AIIntegration id={self.id} name={self.name} type={self.integration_type} active={self.is_active}>"
        
class AIAutomation(db.Model):
    """Model for storing automated AI tasks and workflows."""
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)  # Descriptive name for the automation
    description = db.Column(db.Text, nullable=True)  # Detailed description of what this automation does
    trigger_type = db.Column(db.String(50), nullable=False)  # Type of trigger (e.g., schedule, event, threshold)
    trigger_config = db.Column(db.Text, nullable=False)  # JSON configuration for the trigger
    action_type = db.Column(db.String(50), nullable=False)  # Type of action (e.g., notification, integration, api_call)
    action_config = db.Column(db.Text, nullable=False)  # JSON configuration for the action
    is_active = db.Column(db.Boolean, default=True)  # Whether this automation is currently active
    last_triggered = db.Column(db.DateTime, nullable=True)  # When this automation was last triggered
    execution_count = db.Column(db.Integer, default=0)  # Number of times this automation has been executed
    created_at = db.Column(db.DateTime, default=datetime.now)
    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)
    
    def __repr__(self):
        return f"<AIAutomation id={self.id} name={self.name} trigger={self.trigger_type} active={self.is_active}>"
        
class AutomationLog(db.Model):
    """Model for tracking automation execution history."""
    id = db.Column(db.Integer, primary_key=True)
    automation_id = db.Column(db.Integer, db.ForeignKey('ai_automation.id'), nullable=False)
    status = db.Column(db.String(20), nullable=False)  # Status of execution (success, failure, partial)
    execution_start = db.Column(db.DateTime, nullable=False, default=datetime.now)
    execution_end = db.Column(db.DateTime, nullable=True)
    result = db.Column(db.Text, nullable=True)  # JSON result of the execution
    error = db.Column(db.Text, nullable=True)  # Error message if status is failure
    created_at = db.Column(db.DateTime, default=datetime.now)
    
    # Relationship with automation
    automation = db.relationship('AIAutomation', backref=db.backref('logs', lazy=True))
    
    def __repr__(self):
        return f"<AutomationLog id={self.id} automation_id={self.automation_id} status={self.status}>"
        
class SystemMetric(db.Model):
    """Model for storing system performance metrics."""
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    metric_name = db.Column(db.String(100), nullable=False)  # Name of the metric
    metric_value = db.Column(db.Float, nullable=False)  # Numerical value
    metric_unit = db.Column(db.String(50), nullable=True)  # Unit of measurement
    category = db.Column(db.String(50), nullable=False)  # Category (performance, usage, etc.)
    component = db.Column(db.String(50), nullable=False)  # Component (database, api, ai, etc.)
    timestamp = db.Column(db.DateTime, nullable=False, default=datetime.now)  # When the metric was recorded
    
    def __repr__(self):
        return f"<SystemMetric id={self.id} name={self.metric_name} value={self.metric_value} component={self.component}>"
        
class APIUsageLog(db.Model):
    """Model for tracking API usage."""
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    endpoint = db.Column(db.String(255), nullable=False)  # API endpoint
    method = db.Column(db.String(10), nullable=False)  # HTTP method
    status_code = db.Column(db.Integer, nullable=False)  # HTTP status code
    response_time = db.Column(db.Float, nullable=False)  # Response time in seconds
    user_agent = db.Column(db.String(255), nullable=True)  # User agent
    ip_address = db.Column(db.String(50), nullable=True)  # IP address
    request_payload = db.Column(db.Text, nullable=True)  # Request payload
    timestamp = db.Column(db.DateTime, nullable=False, default=datetime.now)  # When the request was made
    
    def __repr__(self):
        return f"<APIUsageLog id={self.id} endpoint={self.endpoint} status={self.status_code}>"
        
class AIAgentMetrics(db.Model):
    """Model for tracking AI agent performance metrics."""
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    agent_type = db.Column(db.String(50), nullable=False)  # Type of agent
    prompt_version_id = db.Column(db.Integer, db.ForeignKey('prompt_version.id'), nullable=True)  # Related prompt version
    request_count = db.Column(db.Integer, default=0)  # Number of requests
    average_response_time = db.Column(db.Float, default=0.0)  # Average response time in seconds
    average_rating = db.Column(db.Float, default=0.0)  # Average rating (1-5)
    token_usage = db.Column(db.Integer, default=0)  # Total tokens used
    error_count = db.Column(db.Integer, default=0)  # Number of errors
    date = db.Column(db.Date, nullable=False)  # Date of metrics collection
    
    # Relationship with prompt version
    prompt_version = db.relationship('PromptVersion', backref=db.backref('metrics', lazy=True))
    
    def __repr__(self):
        return f"<AIAgentMetrics id={self.id} agent={self.agent_type} date={self.date}>"
        
class NotificationChannel(db.Model):
    """Model for configuring notification channels."""
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)  # Descriptive name
    channel_type = db.Column(db.String(20), nullable=False)  # Type (slack, email, sms)
    config = db.Column(db.Text, nullable=False)  # JSON configuration (recipients, etc.)
    is_active = db.Column(db.Boolean, default=True)  # Whether this channel is active
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.now)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.now, onupdate=datetime.now)
    
    def __repr__(self):
        return f"<NotificationChannel id={self.id} name={self.name} type={self.channel_type}>"

class AlertRule(db.Model):
    """Model for defining alert triggering rules."""
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)  # Rule name
    description = db.Column(db.Text, nullable=True)  # Rule description
    alert_type = db.Column(db.String(50), nullable=False)  # Type of alert to generate
    severity = db.Column(db.String(20), nullable=False)  # Severity to assign
    condition_type = db.Column(db.String(50), nullable=False)  # Type of condition (threshold, pattern, etc.)
    condition_config = db.Column(db.Text, nullable=False)  # JSON configuration for the condition
    component = db.Column(db.String(50), nullable=False)  # Component to monitor
    is_active = db.Column(db.Boolean, default=True)  # Whether this rule is active
    cooldown_minutes = db.Column(db.Integer, default=60)  # Minutes to wait before firing again
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.now)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.now, onupdate=datetime.now)
    
    def __repr__(self):
        return f"<AlertRule id={self.id} name={self.name} type={self.alert_type}>"

class AlertNotificationMap(db.Model):
    """Model for mapping alerts to notification channels."""
    id = db.Column(db.Integer, primary_key=True)
    alert_type = db.Column(db.String(50), nullable=False)  # Type of alert
    min_severity = db.Column(db.String(20), nullable=False)  # Minimum severity level
    channel_id = db.Column(db.Integer, db.ForeignKey('notification_channel.id'), nullable=False)
    is_active = db.Column(db.Boolean, default=True)  # Whether this mapping is active
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.now)
    
    # Relationship
    channel = db.relationship('NotificationChannel', backref=db.backref('alert_mappings', lazy=True))
    
    def __repr__(self):
        return f"<AlertNotificationMap id={self.id} alert_type={self.alert_type} severity={self.min_severity}>"

class MonitoringAlert(db.Model):
    """Model for storing monitoring alerts."""
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    alert_type = db.Column(db.String(50), nullable=False)  # Type of alert (error, warning, etc.)
    severity = db.Column(db.String(20), nullable=False)  # Severity level (critical, error, warning, info)
    component = db.Column(db.String(50), nullable=False)  # Component generating the alert
    message = db.Column(db.Text, nullable=False)  # Alert message
    details = db.Column(db.Text, nullable=True)  # Additional details
    status = db.Column(db.String(20), nullable=False, default='active')  # Status (active, acknowledged, resolved)
    acknowledged_at = db.Column(db.DateTime, nullable=True)  # When the alert was acknowledged
    resolved_at = db.Column(db.DateTime, nullable=True)  # When the alert was resolved
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.now)  # When the alert was created
    alert_rule_id = db.Column(db.Integer, db.ForeignKey('alert_rule.id'), nullable=True)  # Rule that triggered the alert
    notifications_sent = db.Column(db.Boolean, default=False)  # Whether notifications have been sent
    notification_sent_at = db.Column(db.DateTime, nullable=True)  # When notifications were sent
    
    # Relationships
    alert_rule = db.relationship('AlertRule', backref=db.backref('alerts', lazy=True))
    
    def __repr__(self):
        return f"<MonitoringAlert id={self.id} type={self.alert_type} status={self.status}>"
        
class TerraMinerScheduledReport(db.Model):
    """Model for configuring scheduled reports."""
    __tablename__ = 'scheduled_report'
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False)  # Report name
    description = db.Column(db.Text, nullable=True)  # Report description
    report_type = db.Column(db.String(50), nullable=False)  # Type of report (alerts, metrics, etc.)
    schedule_type = db.Column(db.String(20), nullable=False)  # Schedule type (daily, weekly, monthly, custom)
    cron_expression = db.Column(db.String(100), nullable=True)  # Cron expression for custom schedules
    format = db.Column(db.String(20), nullable=False)  # Output format (pdf, html, csv, excel)
    recipients = db.Column(db.Text, nullable=False)  # JSON array of recipient email addresses
    parameters = db.Column(db.Text, nullable=True)  # JSON blob of report parameters
    is_active = db.Column(db.Boolean, default=True)  # Whether this report is active
    last_run = db.Column(db.DateTime, nullable=True)  # When the report was last run
    created_at = db.Column(db.DateTime, nullable=False, default=datetime.now)
    updated_at = db.Column(db.DateTime, nullable=False, default=datetime.now, onupdate=datetime.now)
    
    # Define relationships with our renamed classes and use explicit foreign keys with viewonly mode
    executions = db.relationship(
        'TerraReportExecution',
        foreign_keys="TerraReportExecution.report_id",
        primaryjoin="TerraMinerScheduledReport.id == TerraReportExecution.report_id",
        backref=db.backref('terra_report', lazy=True),
        overlaps="executions,terra_report",
        viewonly=True  # Set to viewonly to avoid bidirectional issues
    )
                                
    # Define relationship with explicit foreign key and viewonly mode
    execution_logs = db.relationship(
        'TerraReportExecutionLog',
        foreign_keys="TerraReportExecutionLog.report_id",
        primaryjoin="TerraMinerScheduledReport.id == TerraReportExecutionLog.report_id",
        backref=db.backref('terra_report', lazy=True),
        overlaps="execution_logs,terra_report",
        viewonly=True  # Set to viewonly to avoid bidirectional issues
    )
    
    def __repr__(self):
        return f"<TerraMinerScheduledReport id={self.id} name={self.name} type={self.report_type}>"
        
class TerraReportExecution(db.Model):
    """Model for tracking report execution history."""
    __tablename__ = 'report_execution'
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    report_id = db.Column(db.Integer, db.ForeignKey('scheduled_report.id'), nullable=False)
    status = db.Column(db.String(20), nullable=False)  # Status of execution (success, failure, partial)
    execution_start = db.Column(db.DateTime, nullable=False, default=datetime.now)
    execution_end = db.Column(db.DateTime, nullable=True)
    output_file_path = db.Column(db.String(255), nullable=True)  # Path to the generated report file
    delivery_status = db.Column(db.String(20), nullable=True)  # Delivery status (sent, failed)
    error = db.Column(db.Text, nullable=True)  # Error message if status is failure
    
    # Relationship with report using the same table name and foreign key
    # Use foreign() annotation to explicitly mark foreign key column
    report = db.relationship('TerraMinerScheduledReport', 
                             foreign_keys=[report_id],
                             primaryjoin="foreign(TerraReportExecution.report_id) == TerraMinerScheduledReport.id",
                             overlaps="executions,terra_report",
                             viewonly=True)
                             
    def __repr__(self):
        return f"<TerraReportExecution id={self.id} report_id={self.report_id} status={self.status}>"
    
class TerraReportExecutionLog(db.Model):
    """Model for logging report execution history with more detailed information."""
    __tablename__ = 'report_execution_log'
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    report_id = db.Column(db.Integer, db.ForeignKey('scheduled_report.id'), nullable=True)
    report_type = db.Column(db.String(50), nullable=False)  # Type of report
    execution_time = db.Column(db.DateTime, nullable=False, default=datetime.now)
    completion_time = db.Column(db.DateTime, nullable=True)
    status = db.Column(db.String(20), nullable=False, default='processing')  # 'success', 'error', 'processing'
    recipient_count = db.Column(db.Integer, default=0)  # Number of recipients
    format = db.Column(db.String(20), nullable=True)  # Report format
    error_message = db.Column(db.Text, nullable=True)  # Error message if status is 'error'
    parameters = db.Column(db.Text, nullable=True)  # JSON of parameters used for the report
    
    # Relationship with report using the same table name and foreign key with explicit foreign annotation
    report = db.relationship('TerraMinerScheduledReport', 
                             foreign_keys=[report_id],
                             primaryjoin="foreign(TerraReportExecutionLog.report_id) == TerraMinerScheduledReport.id",
                             overlaps="execution_logs,terra_report",
                             viewonly=True)
    
    def __repr__(self):
        return f"<TerraReportExecutionLog id={self.id} report_type={self.report_type} status={self.status}>"
        
class NarrprReports(db.Model):
    """Model for storing NARRPR property reports."""
    __tablename__ = 'narrpr_reports'
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(255), nullable=False)
    date = db.Column(db.String(50), nullable=False)
    address = db.Column(db.String(255), nullable=False)
    price = db.Column(db.String(50), nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.now)
    
    # Relationship with PropertyLocation in the same file
    locations = db.relationship('PropertyLocation', foreign_keys='PropertyLocation.report_id', 
                                backref='narrpr_report', lazy=True)
    
    def __repr__(self):
        return f"<NarrprReports id={self.id} title={self.title} address={self.address}>"
        
class PropertyLocation(db.Model):
    """Model for storing geocoded property locations for visualization."""
    __tablename__ = 'property_location'
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    address = db.Column(db.String(255), nullable=False)
    street = db.Column(db.String(100))
    city = db.Column(db.String(100))
    state = db.Column(db.String(50))
    zip_code = db.Column(db.String(20))
    latitude = db.Column(db.Float)
    longitude = db.Column(db.Float)
    price = db.Column(db.String(50))
    price_value = db.Column(db.Integer)  # Stored as integer (cents)
    property_type = db.Column(db.String(50))
    bedrooms = db.Column(db.Integer)
    bathrooms = db.Column(db.Float)
    square_feet = db.Column(db.Integer)
    year_built = db.Column(db.Integer)
    report_id = db.Column(db.Integer, db.ForeignKey('narrpr_reports.id'))
    created_at = db.Column(db.DateTime, default=datetime.now)
    updated_at = db.Column(db.DateTime, default=datetime.now, onupdate=datetime.now)
    
    def __repr__(self):
        return f"<PropertyLocation id={self.id} address={self.address}>"

class PriceTrend(db.Model):
    """Model for storing price trends by location over time."""
    __tablename__ = 'price_trend'
    __table_args__ = {'extend_existing': True}
    
    id = db.Column(db.Integer, primary_key=True)
    location_type = db.Column(db.String(20))  # city, state, zip, etc.
    location_value = db.Column(db.String(100))  # actual city name, state code, zip code
    city = db.Column(db.String(100))
    state = db.Column(db.String(20))
    zip_code = db.Column(db.String(20))
    date = db.Column(db.Date, nullable=False)
    median_price = db.Column(db.Integer)  # Stored as integer (cents)
    avg_price = db.Column(db.Integer)  # Stored as integer (cents)
    price_change = db.Column(db.Float)  # Percentage change from previous month
    properties_sold = db.Column(db.Integer)
    total_listings = db.Column(db.Integer)
    new_listings = db.Column(db.Integer)
    days_on_market = db.Column(db.Float)
    price_per_sqft = db.Column(db.Integer)  # Stored as integer (cents)
    created_at = db.Column(db.DateTime, default=datetime.now)
    
    def __repr__(self):
        return f"<PriceTrend id={self.id} location={self.location_value} date={self.date}>"

class UserActivity(db.Model):
    """Model for tracking user engagement with the platform."""
    __tablename__ = 'user_activity'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer)  # Not using foreign key to avoid circular dependency
    session_id = db.Column(db.String(100))
    activity_type = db.Column(db.String(50))  # search, view_report, generate_report, etc.
    page = db.Column(db.String(255))
    duration_seconds = db.Column(db.Integer)
    device_type = db.Column(db.String(50))
    browser = db.Column(db.String(100))
    ip_address = db.Column(db.String(50))
    timestamp = db.Column(db.DateTime, default=datetime.now)
    activity_metadata = db.Column(db.Text)  # For storing additional activity details as JSON
    
    def __repr__(self):
        return f"<UserActivity id={self.id} type={self.activity_type} user_id={self.user_id}>"

class AIRecommendation(db.Model):
    """Model for tracking AI recommendation engine performance."""
    __tablename__ = 'ai_recommendation'
    
    id = db.Column(db.Integer, primary_key=True)
    user_id = db.Column(db.Integer)  # Not using foreign key to avoid circular dependency
    property_id = db.Column(db.Integer)
    recommendation_type = db.Column(db.String(50))  # similar_property, investment, etc.
    relevance_score = db.Column(db.Float)
    position = db.Column(db.Integer)  # Position in recommendations list
    was_clicked = db.Column(db.Boolean, default=False)
    was_viewed = db.Column(db.Boolean, default=False)
    was_saved = db.Column(db.Boolean, default=False)
    time_to_click = db.Column(db.Integer)  # Time in seconds
    algorithm_version = db.Column(db.String(50))
    created_at = db.Column(db.DateTime, default=datetime.now)
    features_used = db.Column(db.Text)  # Features used for this recommendation as JSON
    
    def __repr__(self):
        return f"<AIRecommendation id={self.id} type={self.recommendation_type} score={self.relevance_score}>"

class ScraperLog(db.Model):
    """Model for tracking scraper performance."""
    __tablename__ = 'scraper_log'
    
    id = db.Column(db.Integer, primary_key=True)
    scraper_name = db.Column(db.String(100))
    target_url = db.Column(db.String(255))
    status = db.Column(db.String(50))  # success, failure, partial_success
    start_time = db.Column(db.DateTime)
    end_time = db.Column(db.DateTime)
    duration_seconds = db.Column(db.Integer)
    items_found = db.Column(db.Integer)
    items_scraped = db.Column(db.Integer)
    error_message = db.Column(db.Text)
    error_type = db.Column(db.String(100))
    retry_count = db.Column(db.Integer, default=0)
    proxy_used = db.Column(db.String(100))
    success_rate = db.Column(db.Float)  # Percentage of successful items
    created_at = db.Column(db.DateTime, default=datetime.now)
    scraper_metadata = db.Column(db.Text)  # For storing additional scraper details as JSON
    
    def __repr__(self):
        return f"<ScraperLog id={self.id} name={self.scraper_name} status={self.status}>"